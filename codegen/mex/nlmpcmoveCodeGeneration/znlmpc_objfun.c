/*
 * znlmpc_objfun.c
 *
 * Code generation for function 'znlmpc_objfun'
 *
 */

/* Include files */
#include "znlmpc_objfun.h"
#include "rt_nonfinite.h"
#include <string.h>

/* Variable Definitions */
static emlrtBCInfo j_emlrtBCI = { 1,   /* iFirst */
  180,                                 /* iLast */
  108,                                 /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "quadraticObjective",                /* fName */
  "C:\\Program Files\\Polyspace\\R2020b\\toolbox\\mpc\\mpcutils\\znlmpc_objfun.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo k_emlrtBCI = { 1,   /* iFirst */
  60,                                  /* iLast */
  135,                                 /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "quadraticObjective",                /* fName */
  "C:\\Program Files\\Polyspace\\R2020b\\toolbox\\mpc\\mpcutils\\znlmpc_objfun.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo l_emlrtBCI = { 1,   /* iFirst */
  60,                                  /* iLast */
  152,                                 /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "quadraticObjective",                /* fName */
  "C:\\Program Files\\Polyspace\\R2020b\\toolbox\\mpc\\mpcutils\\znlmpc_objfun.m",/* pName */
  0                                    /* checkKind */
};

/* Function Definitions */
void quadraticObjective(const emlrtStack *sp, const real_T runtimedata_lastMV[4],
  const real_T runtimedata_ref[60], const real_T runtimedata_OutputWeights[60],
  const real_T runtimedata_MVWeights[60], const real_T
  runtimedata_MVRateWeights[60], const real_T runtimedata_MVScaledTarget[60],
  const real_T X[192], const real_T U[64], real_T e, real_T *f, real_T gfx[180],
  real_T gfu[60], real_T *gfe)
{
  static const int8_T iv[48] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0 };

  real_T b_gfx[12];
  real_T d;
  real_T d1;
  real_T d2;
  real_T d3;
  real_T d4;
  real_T duk_idx_0;
  real_T duk_idx_1;
  real_T duk_idx_2;
  real_T duk_idx_3;
  real_T gfu_idx_1_tmp;
  real_T gfu_idx_2_tmp;
  real_T gfu_idx_3_tmp;
  real_T wtYerr;
  real_T wtYerr_idx_0;
  real_T wtYerr_idx_1;
  real_T wtYerr_idx_2;
  real_T wtYerr_idx_3;
  int32_T b_i;
  int32_T i;
  int8_T iu_idx_0;
  int8_T iu_idx_1;
  int8_T iu_idx_2;
  int8_T iu_idx_3;
  uint8_T gfx_tmp[12];
  uint8_T ix[12];
  uint8_T u;
  memset(&gfx[0], 0, 180U * sizeof(real_T));
  memset(&gfu[0], 0, 60U * sizeof(real_T));
  *f = 0.0;
  for (i = 0; i < 12; i++) {
    ix[i] = (uint8_T)(i + 1U);
  }

  iu_idx_0 = 1;
  iu_idx_1 = 2;
  iu_idx_2 = 3;
  iu_idx_3 = 4;
  for (b_i = 0; b_i < 15; b_i++) {
    /* OUTPUT_FCN */
    /*     H = OUTPUT_FCN(IN1,IN2) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.6. */
    /*     04-Jul-2022 15:43:18 */
    d = runtimedata_OutputWeights[b_i];
    d1 = d * (X[b_i + 1] - runtimedata_ref[b_i]);
    wtYerr = d1 * d1;
    d1 *= d;
    wtYerr_idx_0 = d1;
    d = runtimedata_OutputWeights[b_i + 15];
    d1 = d * (X[b_i + 17] - runtimedata_ref[b_i + 15]);
    wtYerr += d1 * d1;
    d1 *= d;
    wtYerr_idx_1 = d1;
    d = runtimedata_OutputWeights[b_i + 30];
    d1 = d * (X[b_i + 33] - runtimedata_ref[b_i + 30]);
    wtYerr += d1 * d1;
    d1 *= d;
    wtYerr_idx_2 = d1;
    d = runtimedata_OutputWeights[b_i + 45];
    d1 = d * (X[b_i + 129] - runtimedata_ref[b_i + 45]);
    wtYerr += d1 * d1;
    d1 *= d;
    *f += wtYerr;
    for (i = 0; i < 12; i++) {
      u = ix[i];
      if ((u < 1) || (u > 180)) {
        emlrtDynamicBoundsCheckR2012b(u, 1, 180, &j_emlrtBCI, sp);
      }

      gfx_tmp[i] = u;
    }

    for (i = 0; i < 12; i++) {
      b_gfx[i] = gfx[gfx_tmp[i] - 1] + ((((real_T)iv[i] * wtYerr_idx_0 + (real_T)
        iv[i + 12] * wtYerr_idx_1) + (real_T)iv[i + 24] * wtYerr_idx_2) +
        (real_T)iv[i + 36] * d1);
    }

    for (i = 0; i < 12; i++) {
      gfx[gfx_tmp[i] - 1] = b_gfx[i];
      ix[i] = (uint8_T)(ix[i] + 12U);
    }

    wtYerr_idx_0 = U[b_i];
    wtYerr_idx_1 = U[b_i + 16];
    wtYerr_idx_2 = U[b_i + 32];
    wtYerr_idx_3 = U[b_i + 48];
    if (b_i + 1 == 1) {
      duk_idx_0 = wtYerr_idx_0 - runtimedata_lastMV[0];
      duk_idx_1 = wtYerr_idx_1 - runtimedata_lastMV[1];
      duk_idx_2 = wtYerr_idx_2 - runtimedata_lastMV[2];
      duk_idx_3 = wtYerr_idx_3 - runtimedata_lastMV[3];
    } else {
      duk_idx_0 = wtYerr_idx_0 - U[b_i - 1];
      duk_idx_1 = wtYerr_idx_1 - U[b_i + 15];
      duk_idx_2 = wtYerr_idx_2 - U[b_i + 31];
      duk_idx_3 = wtYerr_idx_3 - U[b_i + 47];
    }

    d = runtimedata_MVWeights[b_i];
    d1 = d * (wtYerr_idx_0 - runtimedata_MVScaledTarget[b_i]);
    wtYerr_idx_0 = d1;
    wtYerr = d1 * d1;
    d2 = runtimedata_MVWeights[b_i + 15];
    d1 = d2 * (wtYerr_idx_1 - runtimedata_MVScaledTarget[b_i + 15]);
    wtYerr_idx_1 = d1;
    wtYerr += d1 * d1;
    d3 = runtimedata_MVWeights[b_i + 30];
    d1 = d3 * (wtYerr_idx_2 - runtimedata_MVScaledTarget[b_i + 30]);
    wtYerr_idx_2 = d1;
    wtYerr += d1 * d1;
    d4 = runtimedata_MVWeights[b_i + 45];
    d1 = d4 * (wtYerr_idx_3 - runtimedata_MVScaledTarget[b_i + 45]);
    wtYerr += d1 * d1;
    *f += wtYerr;
    if (iu_idx_0 > 60) {
      emlrtDynamicBoundsCheckR2012b(iu_idx_0, 1, 60, &k_emlrtBCI, sp);
    }

    if (iu_idx_1 > 60) {
      emlrtDynamicBoundsCheckR2012b(iu_idx_1, 1, 60, &k_emlrtBCI, sp);
    }

    if (iu_idx_2 > 60) {
      emlrtDynamicBoundsCheckR2012b(iu_idx_2, 1, 60, &k_emlrtBCI, sp);
    }

    if (iu_idx_3 > 60) {
      emlrtDynamicBoundsCheckR2012b(iu_idx_3, 1, 60, &k_emlrtBCI, sp);
    }

    gfu_idx_1_tmp = gfu[iu_idx_1 - 1];
    gfu_idx_2_tmp = gfu[iu_idx_2 - 1];
    gfu_idx_3_tmp = gfu[iu_idx_3 - 1];
    gfu[iu_idx_0 - 1] += d * wtYerr_idx_0;
    d = runtimedata_MVRateWeights[b_i];
    wtYerr = d * duk_idx_0;
    wtYerr_idx_3 = wtYerr * wtYerr;
    wtYerr *= d;
    duk_idx_0 = wtYerr;
    gfu[iu_idx_1 - 1] = gfu_idx_1_tmp + d2 * wtYerr_idx_1;
    d = runtimedata_MVRateWeights[b_i + 15];
    wtYerr = d * duk_idx_1;
    wtYerr_idx_3 += wtYerr * wtYerr;
    wtYerr *= d;
    duk_idx_1 = wtYerr;
    gfu[iu_idx_2 - 1] = gfu_idx_2_tmp + d3 * wtYerr_idx_2;
    d = runtimedata_MVRateWeights[b_i + 30];
    wtYerr = d * duk_idx_2;
    wtYerr_idx_3 += wtYerr * wtYerr;
    wtYerr *= d;
    duk_idx_2 = wtYerr;
    gfu[iu_idx_3 - 1] = gfu_idx_3_tmp + d4 * d1;
    d = runtimedata_MVRateWeights[b_i + 45];
    wtYerr = d * duk_idx_3;
    wtYerr_idx_3 += wtYerr * wtYerr;
    wtYerr *= d;
    *f += wtYerr_idx_3;
    d = gfu[iu_idx_1 - 1];
    d1 = gfu[iu_idx_2 - 1];
    d2 = gfu[iu_idx_3 - 1];
    gfu[iu_idx_0 - 1] += duk_idx_0;
    gfu[iu_idx_1 - 1] = d + duk_idx_1;
    gfu[iu_idx_2 - 1] = d1 + duk_idx_2;
    gfu[iu_idx_3 - 1] = d2 + wtYerr;
    if (b_i + 1 > 1) {
      if (iu_idx_0 - 4 < 1) {
        emlrtDynamicBoundsCheckR2012b(iu_idx_0 - 4, 1, 60, &l_emlrtBCI, sp);
      }

      if (iu_idx_1 - 4 < 1) {
        emlrtDynamicBoundsCheckR2012b(iu_idx_1 - 4, 1, 60, &l_emlrtBCI, sp);
      }

      if (iu_idx_2 - 4 < 1) {
        emlrtDynamicBoundsCheckR2012b(iu_idx_2 - 4, 1, 60, &l_emlrtBCI, sp);
      }

      if (iu_idx_3 - 4 < 1) {
        emlrtDynamicBoundsCheckR2012b(iu_idx_3 - 4, 1, 60, &l_emlrtBCI, sp);
      }

      wtYerr_idx_1 = gfu[iu_idx_1 - 5] - duk_idx_1;
      wtYerr_idx_2 = gfu[iu_idx_2 - 5] - duk_idx_2;
      wtYerr_idx_3 = gfu[iu_idx_3 - 5] - wtYerr;
      gfu[iu_idx_0 - 5] -= duk_idx_0;
      gfu[iu_idx_1 - 5] = wtYerr_idx_1;
      gfu[iu_idx_2 - 5] = wtYerr_idx_2;
      gfu[iu_idx_3 - 5] = wtYerr_idx_3;
    }

    iu_idx_0 = (int8_T)(iu_idx_0 + 4);
    iu_idx_1 = (int8_T)(iu_idx_1 + 4);
    iu_idx_2 = (int8_T)(iu_idx_2 + 4);
    iu_idx_3 = (int8_T)(iu_idx_3 + 4);
  }

  for (i = 0; i < 180; i++) {
    gfx[i] *= 2.0;
  }

  for (i = 0; i < 60; i++) {
    gfu[i] *= 2.0;
  }

  *f += 100000.0 * e * e;
  *gfe = 200000.0 * e;
}

/* End of code generation (znlmpc_objfun.c) */
